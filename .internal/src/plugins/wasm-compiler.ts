import * as asc from "assemblyscript/asc";
import { Transform } from "assemblyscript/transform";
import { exec } from "child_process";
import { randomUUID } from "crypto";
import fs, { readFile, unlink, writeFile } from "fs/promises";
import { tmpdir } from "os";
import { join, resolve } from "path";
import binaryen from "types:assemblyscript/lib/binaryen";
import util from "util";

// These are the artifacts that will be generated by the compilation process.
export interface BuildArtifacts {
  wasm: Uint8Array;
  dts: string;
  js: string;
  text?: string;
}

class GLMetaAdder extends Transform {
  constructor(private meta: Record<string, string> = {}) {
    super();
  }
  afterCompile(module: binaryen.Module): void {
    const metaBuffer = new TextEncoder().encode(JSON.stringify(this.meta));
    module.addCustomSection("glmeta", metaBuffer);
  }
}

const execAsync = util.promisify(exec);

async function wasmOpt({
  buffer,
  asyncify,
  optimize,
}: {
  buffer: Buffer;
  asyncify?: boolean;
  optimize?: string;
}): Promise<Buffer> {
  const tempIn = join(tmpdir(), `input-${randomUUID()}.wasm`);
  const tempOut = join(tmpdir(), `output-${randomUUID()}.wasm`);

  try {
    await writeFile(tempIn, buffer);

    const args = [tempIn, "-o", tempOut, "--enable-bulk-memory"];
    if (asyncify) {
      args.push("--asyncify", "-n");
    }
    if (optimize) {
      args.push(`-O${optimize}`);
    }

    await execAsync(`wasm-opt ${args.join(" ")}`);

    return await readFile(tempOut);
  } finally {
    await unlink(tempIn).catch(() => {});
    await unlink(tempOut).catch(() => {});
  }
}

export async function compileWasm({
  sourceFiles,
  release,
  asmLibDir,
  levelDir,
  genDir,
  metadata,
}: {
  sourceFiles: string[];
  release: boolean;
  asmLibDir: string;
  levelDir: string;
  genDir: string;
  metadata?: Record<string, string>;
}): Promise<BuildArtifacts> {
  const debug = false;
  const outputFilePath = "main.wasm";
  const textFilePath = "main.wat";

  // Run the spindler command and write its output to dialogue.ts
  const spindlerInput = resolve(levelDir, "story", "Level.twee");
  const spindlerOutput = resolve(genDir, "dialogue.ts");
  try {
    const { stdout } = await execAsync(`spindler ${spindlerInput}`);
    await fs.writeFile(spindlerOutput, stdout);
  } catch (error) {
    throw new Error(`Dialogue generation failed: ${error}`);
  }

  const commandLineOptions = [
    ...sourceFiles,
    "--outFile",
    outputFilePath,
    "--target",
    "release",
    "--bindings",
    "raw",
    "--importMemory",
    "--exportRuntime",
    "--path",
    asmLibDir,
  ];
  if (debug) {
    commandLineOptions.concat(["--textFile", textFilePath]);
  }

  const artifacts: Partial<BuildArtifacts> = {};

  const stderr = asc.createMemoryStream();

  // Compile AssemblyScript programmatically
  const { error } = await asc.main(commandLineOptions, {
    stdout: process.stdout,
    stderr: stderr,
    transforms: [new GLMetaAdder(metadata)],
    writeFile: async (fileName, contents) => {
      const extension = fileName.split(".").pop();
      if (extension === "wasm") {
        artifacts.wasm = await wasmOpt({
          buffer: contents as Buffer,
          asyncify: true,
          optimize: release ? "3" : undefined,
        });
      } else if (extension === "ts") {
        artifacts.dts = contents as string;
      } else if (extension === "js") {
        artifacts.js = contents as string;
      } else if (extension === "wat") {
        artifacts.text = contents as string;
      } else {
        throw new Error(`Unknown file extension: ${extension}`);
      }
    },
  });

  if (error) {
    throw { message: stderr.toString() };
  } else {
    return artifacts as BuildArtifacts;
  }
}
